## 牛客C++面试题补习
### 一些常见的C++面试题总结
说在前面，三种内存限制：1 是静态代码和数据段，包括静态、常量、全局等。2是动态（堆）数据，存储在堆，由new/malloc生成。3是栈数据，存储在栈，由编译器自动分配释放，存放函数参数、局部变量等。
通常我们把 **1称为静态存储区** ，**2、3称为动态存储区**。
#### 1. static关键字的作用（定义在静态存储区）
- 全局静态变量：属于文件，作用域只在定义它的文件中。
- 局部静态变量：属于函数，作用域只在定义它的函数或语句块中,且共享一个。
- 静态函数：属于文件，作用域只在定义它的文件中。
- 类的静态成员：属于类，不属于任何一个实例，故所有实例可以共享它。注意它不能在类内初始化，必须在类外。
- 类的静态函数：属于类，不属于任何一个实例；实现时只能调用类内其他静态成员，可直接用类名调用静态成员函数```foo::staticTest()```。

#### 2. explicit关键字
**隐式转换和显式转换** 。隐式转换是系统根据程序需要自动做的转换。显示转换是强制转换。
在类中，对于只有一个参数的构造函数（多个参数则不会隐式转换，当然如果其他参数有默认值就仍会隐式转换），系统可能发生隐式转换。 用 **explicit** 关键字在构造函数前声明指定必须显式调用。相对的关键字 **implicit** 意思是隐藏的，类构造函数默认为implicit。

#### 3. C++中四种cast转换
static_cast， dynamic_cast， const_cast， reinterpret_cast
- static_cast，系统可能进行的任何隐式转换都可由它显式进行，如非const转const，void*转指针等，static_cast能用于多态向上转化，如果向下转能成功但不安全，结果未知。
- dynamic_cast，动态类型转换，只能用于含有虚函数的类，用于层次间的向上和向下转化。只能转指针或引用。向下转化事，如果非法，对于指针返回NULL，引用抛出异常。
- const_cast，用于将const变量转化为非const。
- reinterpret_cast，几乎也什么都能转，但可能会出问题，少用。

#### 4. 指针和引用区别
指针有自己的一块空间，使用时可改变指向的对象，需解引用获取指向的对象，可以有多级，大小为4；引用只是一个别名，只能是一个对象的引用不能被改变，大小为引用的对象大小。

#### 5.  理解C++的四个智能指针
智能指针用于管理堆上分配的内存，且都能自动调用析构函数释放资源，而不需要手动delete，原理是将普通指针封装成一个栈对象，栈对象生命周期结束后，会在析构函数种释放申请的内存。
auto_ptr，shared_ptr，weak_ptr，unique_ptr，其中后三个是C++11支持，第一个已经被弃用。
- unique_ptr实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象内存，对于避免资源泄漏特别有用。
```
unique_ptr<string> p1 (new string("this"));
unique_ptr<string> p2;
//p2 = p1; //error，会报错p1指向的内存只能被独占
p2 = move(p1); //allowed，使用move把指针p1指向的内存给p2
```
- shared_ptr实现共享式拥有概念，多个智能指针可以指向相同的对象，最好用make_shared初始化智能指针```shared_ptr<string> p1 = make_shared<string>("helloworld")```，也可用指针初始化```shared_ptr<A> p1(new A())```，使用p1.get()获取内部普通指针，生命周期使用引用计数的方法。当引用计数为0时，资源会被释放。当shared_ptr指针指向的某对象被创建时引用计数为1，该对象每次被其他指向又会加1。当超出作用域要释放该对象时，会使引用计数减1，为0则析构，否则释放不了。于是可能死锁。
- weak_ptr，弱指针是一种不控制对象生命周期的指针，指向一个shared_ptr管理的对象。为了解决强指针相互引用死锁的问题，如果两个shared_ptr相互引用，那么它们的引用计数永远不可能减为0，资源永远不会释放。而弱指针不会增加shared_ptr的引用计数，和shared_ptr可以相互转化，且可以直接赋值给它。
```
#include <iostream>
#include <memory>
using namespace std;
class B;
class A{
public:
    shared_ptr<B> pb_;
    ~A(){
        cout<<"delete A"<<endl;
    }
};
class B{
public:
    // shared_ptr<A> pa_;
    weak_ptr<A> pa_;
    ~B(){
        cout<<"delete B"<<endl;
    }
};
void fun()
{
    shared_ptr<B> pb(new B());
    shared_ptr<A> pa(new A());
    pb->pa_ = pa;
    pa->pb_ = pb;
    cout<<pb.use_count()<<endl;
    cout<<pa.use_count()<<endl;
}
int main()
{
    fun();
    return 0;
}
```

#### 6. virtual关键字，虚函数原理是什么？构造函数和析构函数能否为虚函数？纯虚函数的理解？
(1) **虚函数的原理由虚表实现，父类声明了virtual关键字的函数，在子类中重写时不需要加virtual也是虚函数** 。虚表是属于类的，每个包含虚函数的类都包含一个虚表。虚表会记录该类指向的虚函数(重载了父类的虚函数则创建新的指向，未重载的则指向父类的虚函数）。每个对象在实例化时创建了一个指向自己所使用虚表的指针_vptr，故实例创建时就决定了自己用的是自己创建时的类的虚表，而不会因为后来的赋值转换而改变。故多态使用时```A* p = new B;```父类型A的指针p创建时就决定了用子类B的虚表，故调用重载的虚方法fun时```p->fun()```会调用B的而不是A的。<br>
(2) **构造函数不能为虚函数， 析构函数可以且常常是虚函数。**
- 构造函数必不能是虚函数，因为指向虚表的指针在构造函数中才初始化的。
- 析构函数可以且常常是虚函数。首先，默认析构函数为了减少虚表开销，所以不是虚函数。其次，正确的析构顺序应该是派生类->成员类->基类。对于(1)中多态的例子，```delete p```将会只调用A的析构函数，故需要把A析构函数写成虚函数```virtual ~A(){};```才能链式调用先析构B再析构A，多个继承也一样。故析构时需要把基类的析构函数写成虚函数，保证多态中析构时先根据子类的虚表调用子类析构再调用父类的析构。
(3) **纯虚函数不用实现，一般用于定义基类的接口，子类必须实现父类的纯虚函数。且含纯虚函数的类不能实例化。**纯虚函数其实可以在类外面实现。所以**析构函数可以是纯虚的，但纯虚析构函数必须有定义体，因为析构函数的调用是在子类中隐含的，但个人认为意义不大**。



#### 7. 函数指针和指针函数
指针函数是一个函数，函数指针是一个指针。
- 指针函数代表返回的值是类型是一个指针```int* fun(){}```
- 函数指针是为了构造一种指针指向某个或某种函数。如下代码利用typedef关键字实现了字符对应不同的函数写入到了map中。
```
typedef void (ObjModel::*fun)(Vector3f);
    std::map<std::string, fun> funMap;
    funMap["v"]  = &ObjModel::addVertex;
    funMap["vt"] = &ObjModel::addVTexture;
    funMap["vn"] = &ObjModel::addVNormal;
    funMap["f"]  = &ObjModel::addFace;
```

#### 8. const关键字的作用
- const修饰普通对象，代表是常量不能被更改。修饰指针时比较特殊 ```const char* p = &a``` 表示指针p可以修改，*p不能被修改； ```char* const p = &a```表示指针p不可变，*p可变；```const int* const p = &a``` 表示p和*p都不能修改。
- const修饰指针或引用函数参数 ```void fun(const int* p){}```，传入的参数代表的内容在函数内不能被更改。但仅对指针和引用有用，因为其他的参数都是复制的值。
- const修饰函数返回值为指针或引用 ```const int &fun(){}```, 防止返回的值后被修改（防止函数返回值为左值 如fun()=1）。
- const修饰成员函数 ```void fun() const{}```，表明函数调用不会对对象做出任何更改，也就是不能修改对象数据成员，且const函数内部只能调用const函数。因此，如果确认不会对对象做更改，就应该为函数加上const限定，这样无论const对象还是普通对象都可以调用该函数。

#### 9. 写一个单例模式
思路是把类构造函数写成私有成员，在公有成员函数中调用构造函数
```
class foo{
public:
	static foo* getInstace()
    {
    	if(_instance == nullptr)
        	_instance = new foo();
        return _instance;
    }
private:
	foo(){};
    static foo* _instance;
}
foo* foo::_instance = nullptr;
...
int main()
{
	foo* fooInstance1 = foo::getInstance();
    foo* fooInstance2 = foo::getInstance(); //fooInstance1和fooInstance2指向了同一个实例
	return 0;
}
```

#### 10. 关于运算符重载
#### 11. 关于进程，fork，wait，exec函数
父进程产生子进程使用fork拷贝出来一个父进程的副本，此时只拷贝了父进程的页表，两个进程都读同一块内存，当有进程写的时候使用写实拷贝机制分配内存，exec函数可以加载一个ELF文件去替换父进程，从此父进程和子进程就可以运行不同的程序。fork从父进程返回子进程的pid，从子进程返回0。调用了wait的父进程将会发生阻塞，直到有子进程状态发生改变，执行成功返回0，错误返回-1。exec执行成功则子进程从新的程序开始运行，无返回值，执行失败返回-1。
#### 12.  关于线程
#### 一些小问题 
- 野指针是什么? 野指针就是指向一个已删除对象或者未申请访问受限内存区域的指针。
- C++栈空间大小默认是1M，不过可以调整
- C++调用C函数需要extern C，因为C语言没有重载。
- C语言参数压栈顺序是从右往左的。
- C++如何处理返回值？生成一个临时变量，把它的值作为函数参数传入函数内。
- malloc需要给定申请内存大小，返回指针需要强转；new会调用构造函数，不用指定内存大小，返回的指针不用强转。
- 说说你了解的RTTI（Run-Time Type Identification）？在C++层面主要体现在dynamic_cast和typeid，VS中虚函数表的-1位置存放了指向指向type_info的指针，对于存在虚函数的类型，typeid和dynamic_cast都会去查询type_info。
- C语言的每一个函数调用都会分配函数栈，在栈内进行函数执行过程，调用前，先把返回地址压栈，然后把当前函数的eps指针压栈（eps指针是什么？）。

### 有关STL面试题（待完善）
STL主要由容器迭代器、仿函数算法、分配器、配接器组成。
分配器给容器分配内存空间，算法通过迭代器获取容器中的内容，仿函数可以协助算法完成各种操作，配接器用来套接适配仿函数。
#### 1. map和set有什么区别，分别是怎么实现的？
map和set都是C++的关联容器，其底层实现都是红黑树(RB-Tree)。由于map和set所开放的各种操作接口，所以几乎所有的map和set操作都是转调红黑树的操作行为。然后区别就是map和set的一些方法。
#### 2. 介绍一下STL的allocaotr
STL
#### 3. STL迭代器删除元素
说在前面，STL容器有两种存储方式，一种是节点式容器(map，list，set等)，节点式容器的插入删除操作会导致该元素失效，其他元素不受影响；另一种式顺序式容器(vector, string, deque等)，顺序式容器的插入删除操作会导致指向该元素以及后面的元素迭代器都失效。于是以上就出现了在循环中插入删除迭代器元素出现程序崩溃的问题，因为操作后it++会失效。（待验证）
