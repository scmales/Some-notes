
#### 进程
说在前面。 **进程=程序+数据+进程控制块** 。进程控制块称PCB，OS为每个进程维护一个PCB用来保存进程的各种状态信息。
- 进程的状态：**运行状态、就绪状态、等待状态（阻塞状态）、创建状态、结束状态** 。一个进程创建好后进入就绪状态；就绪状态是一个进程获得了除处理及外的一切所需资源，一旦被调度得到处理机就进入运行状态；运行状态是一个进程正在处理机上运行；阻塞状态是一个进程正在等待某一事件或请求系统资源失败而暂停运行；运行状态时间片用完转成就绪状态；或者运行状态要等待其他事件时转成阻塞状态，阻塞状态在等待的事件发生时又能转成就绪状态。
- 挂起状态：挂起不同于阻塞。 **挂起是把进程从内存转到外存** ，挂起的进程映像在磁盘上。阻塞挂起状态，进程在外存等待某事件的出现；就绪挂起状态，在外存挂起，进入内存则运行。加入挂起状态后和基本状态的转换就有点多了，待补充。
- 状态队列：OS维护一组状态队列，每个PCB根据自己进程的状态加入到不同的状态队列中。
- 进程调度：抢占式和非抢占式的方式。调度方法有先来先服务、短作业优先、优先级调度、高响应比优先调度、时间片轮转、多级反馈队列。

#### 进程间通信方式
以下是操作系统王道书中的说法：
- PV操作是低级通信方式
- 共享存储：通信进程之间存在一块可直接访问的共享空间，通过对这片共享空间进行读写操作实现进程之间的信息交换。对共享空间操作时需要使用同步互斥工具（PV操作）。共享存储分为2种，低级的方式的共享是基于数据结构的共享；高级方式则是基于存储区的共享。操作系统只负责为通信进程提供可共享使用的存储空间和同步互斥工具
- 消息传递：进程间的数据交换以格式化的消息为单位传递。利用OS提供的发送消息和接收消息两个原语进行数据交换。有直接通信方式和间接通信方式。
- 管道通信：管道是用于连接一个读进程和一个写进程以实现它们之间通信的一种共享文件，又名pipe文件，实际上是一个缓冲区。必须有以下三方面的协调能力：互斥、同步、确定对方存在。管道可以理解为共享存储的优化和发展，共享存储时必须要独占，而管道缓冲区可以一边写入，另一边读出。

以下为知乎的答案说法：
- 共享内存：将某一进程绑定映射到共享内存即可。 用来实现进程间共享的、非常庞大的、读写操作频率很高的数据（配合信号量使用），这种方式通常适用于多进程间通信。。
- PIPE和FIFO用来实现进程间相互发送非常短小的、频率很高的消息；这两种方式通常适用于两个进程间的通信。
- 其他考虑用socket。这里的“其他情况”，其实是今天主要会碰到的情况：分布式开发。在多进程、多线程、多模块所构成的今天最常见的分布式系统开发中，socket是第一选择。
- 消息队列，现在建议不要使用了 ---- 因为找不到使用它们的理由。消息队列说白了就是“高级一点儿的PIPE/FIFO”，但是这种“高级”相较于现在常见的业务场景来说其实一点儿都不高级：没有容灾、没有弹性伸缩......因此不建议使用消息队列。现在有很成熟的各种MQ，比如RabbitMQ、ZeroMQ等。一句话，业务场景很简单、对性能有要求，就用PIPE、FIFO、共享内存，业务场景复杂，就用现在已经很成熟的那些MQ。


简单写写C++进程的demo，fork()函数返回值为：若该进程为父进程，返回子进程的pid;若该进程为子进程，则返回0；fork执行失败，返回-1； **fork会在执行处尝试复制一个子进程，并且子进程和父进程会把这个fork后面的代码都执行一次。**
```
#include <iostream>
using namespace std;
 
#include <unistd.h>  
#include <stdio.h>   
int main()   
{   
	int i =0;
    for (; i<2; i++)
    {
        fork();
        printf("a\n"); //有\n会刷新缓冲区，故正常打印
    }    
}
//运行结果为
a
a
a
a
a
a
```
```
#include <iostream>
using namespace std;
 
#include <unistd.h>  
#include <stdio.h>   
int main()   
{   
	int i =0;
    for (; i<2; i++)
    {
        fork();
        printf("a");//无\n不会刷新打印缓冲区，所以第二次循环打印会把第一轮留在缓冲区的a也打印出来
    }    
}
//运行结果为
aaaaaaaa
```
#### 线程
线程为了更好地实现并发执行，以提高资源利用率和系统吞吐量。 **进程=线程+资源管理** 。 **线程=线程ID+程序计数器+寄存器集合+堆栈** 。同样，线程有线程控制器TCB。若一个线程崩溃破坏了共享资源，会导致所属的所有线程崩溃。
- 线程可分为用户级线程和内核级线程。

#### 线程的通信方式
- 通过共享一个全局变量就可以实现，但要把全局变量声明为volatile。（要做互斥操作）
- Message消息机制。如PostThreadMessage是任意两个线程间的通信接口。

简单写写C++线程的demo
```
//多线程
#include<map>
#include<iostream>
#include<thread>
#include<list>
#include<mutex>
#include<string>
#include<vector>
using namespace std;
class A
{
public:
    //线程一，入队列
    void inMsgRecvQ()
    {
        for (int i = 0; i < 100000; i++)
        {
            cout << "接收消息的线程执行，插入一个元素  " << i << endl;
            my_mutex.lock();
            msgRecvQ.push_back(i);//假设数字i就是玩家收到的命令
            my_mutex.unlock();
        }
    }
    bool outMsgDispose(int &command)
    {
        my_mutex.lock();
        if (!msgRecvQ.empty())
        {
            //表示消息队列不为空
            command = msgRecvQ.front();//返回第一个元素，但不检查元素是否存在
            msgRecvQ.pop_front();          //移除第一个元素，不返回
            my_mutex.unlock();
            return true;
        }
        my_mutex.unlock();
        return false;
    }
    //线程二，从消息队列中去数据
    void outMsgRecvQ()
    {
        int comment = 0;
        for (int i = 0; i < 100000; i++)
        {
            bool result = outMsgDispose(comment);
            if (result==true)
            {
                cout << "线程一执行，取出一个元素" << comment << endl;
            }
            else
            {
                cout << "读取消息队列执行，但目前队列中没有信息！ " << i<<endl;
            }
        }
        cout << "线程二执行完毕！" << endl;
    }

private:
    list<int> msgRecvQ;//容器，用于接收玩家发过来的命令
    mutex my_mutex;
};


int main()
{
    A myTask;
    thread myOutMsgThread(&A::outMsgRecvQ, &myTask);//第二个参数是引用类型，这样才能保证线程里用的是同一个对象
    thread myInMsgThread(&A::inMsgRecvQ, &myTask);

    myInMsgThread.join();
    myOutMsgThread.join();

    return 0;
}
```

#### 线程和进程的区别
- **进程是资源分配的单位，线程是CPU调度的单位。**
- 进程之间的地址空间相互独立，同一进程内的各线程共享进程的资源，某进程内的线程对其他进程不可见。
- 线程同样具有就绪，阻塞和执行三种基本状态，同样具有状态之间的转换，且同样可以并发执行。
- 线程能减少并发执行的时间和空间开销：

#### 线程栈
线程有自己的 stack，但是没有单独的 heap，也没有单独的 address space。<br>
只有进程有自己的 address space，而这个 space 中经过合法申请的部分叫做 process space。Process space 之外的地址都是非法地址。当一个线程向非法地址读取或者写入，无法确认这个操作是否会影响同一进程中的其它线程，所以只能是整个进程一起崩溃。


#### 操作系统的用户态和内核态
操作系统和CPU配合，设置用户模式和特权模式。对应用户态和内核态,是CPU的两种状态。 **进入内核态可以理解为，CPU在执行操作系统内核的代码** 。应用程序无法自由进入内核态，只能通过操作系统提供的接口调用进入，或者在硬件中断到来时被动进入。为什么要限制应用程序的行为？ **如果它能控制所有的物理内存，那么它就能改变计算机的任意状态，甚至把自己变成操作系统** 。所以要限制应用程序的行为，必须在应用程序和操作系统执行时有不同的状态，核心问题在于保护关键寄存器和重要的物理内存。
- 用户态到内核态可以通过 **系统调用、异常、外设中断** 完成切换。比如 **库函数实现了系统调用的封装** ，方便程序员实现系统调用。

#### 同步和互斥
- 同步又称直接约束关系，两个进程（线程）要协调它们的工作次序，比如加法要在乘法后进行，不然会出错。
- 互斥，一个资源只能被一个进程（线程）使用，是指临界资源只能被独占。
常用信号量来实现PV操作，即实现同步和互斥。P操作其实是申请资源，V操作其实是释放资源。

#### 临界区；互斥量（互斥锁）；信号量
- 临界区就是代码的一个区间，可能能占有它的进程（线程）有限，比如如果只能有一个进程能访问它就必须保证它互斥。
- **OS使用sleep和wakeup原语，保证同一时刻只有一个线程进入临界区代码片段的锁叫“互斥量”。
把互斥锁推广到"N"的空间，同时允许有N个线程进入临界区的锁叫“信号量”。**  互斥锁作用就是互斥（资源量只能是0、1），自旋锁是互斥锁的一种实现方式，相比一般的互斥锁会在等待期间放弃cpu，自旋锁（spinlock）则是不断循环并测试锁的状态，这样就一直占着cpu。信号量是一种更高级的同步(资源量可以很多)不止能实现互斥，还能实现同步。
#### 悲观锁和乐观锁
悲观并发控制实际上是 “先取锁，再访问” 的保守策略，为数据处理的安全提供了保证。
乐观锁假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测。