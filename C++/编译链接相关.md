#### 1. 有关编译链接过程<br>
##### linux下的编译链接过程gcc hello.c，以下C++用g++替换<br>
**预处理** 生成hello.i文件，处理源码种以#开始的预编译指令。<br>
```gcc -E hello.c -o hello.i``` <br>
**编译** 过程就是生成汇编代码文件汇hello.s, 把预处理完的文件进行一系列语法、语义分析。<br>
```gcc -S hello.i -o hello.s```<br>
**汇编** 就是生成机器可执行命令hello.o目标文件, 将汇编代码转变成机器可以执行的命令。<br>
```gcc -c hello.c -o hello.o```<br>
**链接** 就是将各个目标文件组装在一起，解决符号依赖、库依赖关系，并生成可执行文件。<br>
```
ld –static crt1.o crti.o crtbeginT.o hello.o –start-group –lgcc –lgcc_eh –lc-end-group crtend.o crtn.o
```
不得不提gcc的一些参数如下：
- -c, 只编译，不链接成可执行文件
- -o， 后接确定输出文件的名称
- -g， 用于调试的工具
- -O， 对程序进行优化编译链接，增加可执行文件的执行效率，但编译链接的速度就要慢很多。
- -O2，比-O更好的优化。

#### 2. 静态链接和动态链接
说在前面，linux下可执行文件的后缀名不一定。
```gcc hello.c -o hello.xxx```
但若未指定生成的可执行文件名字，将会生成默认名为```a.out```文件作为可执行文件。<br>
**linux下的"可执行文件格式"为ELF(Executalbe Linkable Format)，包括可执行文件、可重定向文件(目标文件.o、静态链接库.a)、共享目标文件(动态库.so)、核心转储(core dump)。** <br>
- 静态链接就是将几个输入的目标文件.o加工合并成一个输出文件。我们可以简单认为 **一个静态链接库.a是多个.o的组合 ** ，可利用ar工具查看。于是生成静态链接库.a的时候是以目标文件.o为单位的，只要用到了某个目标文件中定义的符号，就要把它链接进来，于是这样可能导致大量的目标文件.o被重复使用。
- 动态链接把程序按照模块拆分成相对独立的部分，在程序运行时才将它们链接在一起形成一个完成的，而不是像静态链接一样先把所有目标文件链接成一个单独的可执行文件。动态链接好处，一是共享对象在磁盘和内存只有一份；二是升级某一个共享模块时，只需要将目标文件替换，而无须将所有的程序重新链接。